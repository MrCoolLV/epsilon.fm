
// File: /opt/src/epsilon.fm/tests/test.ts
import { expect, test } from '@playwright/test';

test('home page has expected h1', async ({ page }) => {
	await page.goto('/');
	await expect(page.locator('h1')).toBeVisible();
});


// File: /opt/src/epsilon.fm/src/app.d.ts
// See https://kit.svelte.dev/docs/types#app
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};


// File: /opt/src/epsilon.fm/src/hooks.client.ts
import * as Sentry from '@sentry/sveltekit';
import type { HandleClientError } from '@sveltejs/kit';
// To use Clerk components:
import { initializeClerkClient } from 'clerk-sveltekit/client';
// Or for headless mode:
// import { initializeClerkClient } from 'clerk-sveltekit/headless'
import { PUBLIC_CLERK_PUBLISHABLE_KEY } from '$env/static/public';

// If you don't want to use Session Replay, remove the `Replay` integration,
// `replaysSessionSampleRate` and `replaysOnErrorSampleRate` options.
Sentry.init({
	dsn: 'https://d677a865e0302d7c39f61a919db18993@o337159.ingest.us.sentry.io/4507546312572928',
	tracesSampleRate: 1,
	replaysSessionSampleRate: 0.1,
	replaysOnErrorSampleRate: 1,
	integrations: [Sentry.replayIntegration()]
});

initializeClerkClient(PUBLIC_CLERK_PUBLISHABLE_KEY, {
	afterSignInUrl: '/',
	afterSignUpUrl: '/',
	signInUrl: '/sign-in',
	signUpUrl: '/sign-up'
});

export const handleError: HandleClientError = Sentry.handleErrorWithSentry(
	async ({ error, event }) => {
		console.error(error, event);
	}
);


// File: /opt/src/epsilon.fm/src/hooks.server.ts
import * as Sentry from '@sentry/sveltekit';
import { sequence } from '@sveltejs/kit/hooks';
import { handleClerk } from 'clerk-sveltekit/server';
import { SENTRY_DSN, CLERK_SECRET_KEY } from '$env/static/private';
import { redirect } from '@sveltejs/kit';
import type { Handle } from '@sveltejs/kit';

type SubdomainRoutes = {
	[key: string]: string;
};

Sentry.init({
	dsn: SENTRY_DSN,
	tracesSampleRate: 1
});

export const handleSubdomain: Handle = async ({ event, resolve }) => {
	const { url } = event.request;
	const parsedUrl = new URL(url);
	const subdomain = parsedUrl.hostname.split('.')[0]; // Get the subdomain
	console.log(parsedUrl);
	console.log(subdomain);
	// Define your subdomain to route mappings
	const subdomainRoutes: SubdomainRoutes = {
		sub1: '/route1',
		sub2: '/route2'
		// Add more mappings as needed
	};

	if (subdomain in subdomainRoutes) {
		const newUrl = new URL(parsedUrl);
		newUrl.pathname = subdomainRoutes[subdomain as keyof SubdomainRoutes];
		console.log(newUrl.toString());
		return redirect(302, newUrl.toString());
	}

	// If no matching subdomain, continue to the requested route
	return await resolve(event);
};

export const handle: Handle = sequence(
	Sentry.sentryHandle(),
	handleClerk(CLERK_SECRET_KEY, {
		debug: false,
		protectedPaths: [
			'/admin',
			'/profile',
			'/releases',
			'/merch',
			'/website',
			'/social',
			'/royalties'
		],
		signInUrl: '/sign-in'
	}),
	handleSubdomain
);
export const handleError = Sentry.handleErrorWithSentry();


// File: /opt/src/epsilon.fm/src/lib/utils.ts
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";
import { cubicOut } from "svelte/easing";
import type { TransitionConfig } from "svelte/transition";

export function cn(...inputs: ClassValue[]) {
	return twMerge(clsx(inputs));
}

type FlyAndScaleParams = {
	y?: number;
	x?: number;
	start?: number;
	duration?: number;
};

export const flyAndScale = (
	node: Element,
	params: FlyAndScaleParams = { y: -8, x: 0, start: 0.95, duration: 150 }
): TransitionConfig => {
	const style = getComputedStyle(node);
	const transform = style.transform === "none" ? "" : style.transform;

	const scaleConversion = (
		valueA: number,
		scaleA: [number, number],
		scaleB: [number, number]
	) => {
		const [minA, maxA] = scaleA;
		const [minB, maxB] = scaleB;

		const percentage = (valueA - minA) / (maxA - minA);
		const valueB = percentage * (maxB - minB) + minB;

		return valueB;
	};

	const styleToString = (
		style: Record<string, number | string | undefined>
	): string => {
		return Object.keys(style).reduce((str, key) => {
			if (style[key] === undefined) return str;
			return str + `${key}:${style[key]};`;
		}, "");
	};

	return {
		duration: params.duration ?? 200,
		delay: 0,
		css: (t) => {
			const y = scaleConversion(t, [0, 1], [params.y ?? 5, 0]);
			const x = scaleConversion(t, [0, 1], [params.x ?? 0, 0]);
			const scale = scaleConversion(t, [0, 1], [params.start ?? 0.95, 1]);

			return styleToString({
				transform: `${transform} translate3d(${x}px, ${y}px, 0) scale(${scale})`,
				opacity: t
			});
		},
		easing: cubicOut
	};
};

// File: /opt/src/epsilon.fm/src/lib/stores/main.ts
import { writable } from 'svelte/store';

export const slug = writable('');


// File: /opt/src/epsilon.fm/src/lib/stores/website.ts
import { writable } from 'svelte/store';

export const modalOpened = writable(false);
export const customBackground = writable('#0a0908');


// File: /opt/src/epsilon.fm/src/lib/stores/clerk.ts
import { writable } from 'svelte/store';

const clerkStore = writable(null);

export default clerkStore;


// File: /opt/src/epsilon.fm/src/lib/server/uploadthing.ts
import { createUploadthing } from 'uploadthing/server';
import type { FileRouter } from 'uploadthing/server';

const f = createUploadthing();

const auth = (req: Request) => ({ id: 'fakeId' }); // Fake auth function

// FileRouter for your app, can contain multiple FileRoutes
export const ourFileRouter = {
	// Define as many FileRoutes as you like, each with a unique routeSlug
	imageUploader: f({ image: { maxFileSize: '4MB' } })
		// Set permissions and file types for this FileRoute
		.middleware(async ({ req }) => {
			// This code runs on your server before upload
			const user = await auth(req);

			// If you throw, the user will not be able to upload
			if (!user) throw new Error('Unauthorized');

			// Whatever is returned here is accessible in onUploadComplete as `metadata`
			return { userId: user.id };
		})
		.onUploadComplete(async ({ metadata, file }) => {
			// This code RUNS ON YOUR SERVER after upload
			console.log('Upload complete for userId:', metadata.userId);

			console.log('file url', file.url);
		})
} satisfies FileRouter;

export type OurFileRouter = typeof ourFileRouter;


// File: /opt/src/epsilon.fm/src/lib/utils/uploadthing.ts
import type { OurFileRouter } from '$lib/server/uploadthing';

import { generateSvelteHelpers } from '@uploadthing/svelte';

export const { createUploader, createUploadThing } = generateSvelteHelpers<OurFileRouter>();


// File: /opt/src/epsilon.fm/src/lib/components/ui/form/index.ts
import * as FormPrimitive from "formsnap";
import Description from "./form-description.svelte";
import Label from "./form-label.svelte";
import FieldErrors from "./form-field-errors.svelte";
import Field from "./form-field.svelte";
import Fieldset from "./form-fieldset.svelte";
import Legend from "./form-legend.svelte";
import ElementField from "./form-element-field.svelte";
import Button from "./form-button.svelte";

const Control = FormPrimitive.Control;

export {
	Field,
	Control,
	Label,
	Button,
	FieldErrors,
	Description,
	Fieldset,
	Legend,
	ElementField,
	//
	Field as FormField,
	Control as FormControl,
	Description as FormDescription,
	Label as FormLabel,
	FieldErrors as FormFieldErrors,
	Fieldset as FormFieldset,
	Legend as FormLegend,
	ElementField as FormElementField,
	Button as FormButton,
};


// File: /opt/src/epsilon.fm/src/lib/components/ui/calendar/index.ts
import Root from "./calendar.svelte";
import Cell from "./calendar-cell.svelte";
import Day from "./calendar-day.svelte";
import Grid from "./calendar-grid.svelte";
import Header from "./calendar-header.svelte";
import Months from "./calendar-months.svelte";
import GridRow from "./calendar-grid-row.svelte";
import Heading from "./calendar-heading.svelte";
import GridBody from "./calendar-grid-body.svelte";
import GridHead from "./calendar-grid-head.svelte";
import HeadCell from "./calendar-head-cell.svelte";
import NextButton from "./calendar-next-button.svelte";
import PrevButton from "./calendar-prev-button.svelte";

export {
	Day,
	Cell,
	Grid,
	Header,
	Months,
	GridRow,
	Heading,
	GridBody,
	GridHead,
	HeadCell,
	NextButton,
	PrevButton,
	//
	Root as Calendar,
};


// File: /opt/src/epsilon.fm/src/lib/components/ui/card/index.ts
import Root from "./card.svelte";
import Content from "./card-content.svelte";
import Description from "./card-description.svelte";
import Footer from "./card-footer.svelte";
import Header from "./card-header.svelte";
import Title from "./card-title.svelte";

export {
	Root,
	Content,
	Description,
	Footer,
	Header,
	Title,
	//
	Root as Card,
	Content as CardContent,
	Description as CardDescription,
	Footer as CardFooter,
	Header as CardHeader,
	Title as CardTitle,
};

export type HeadingLevel = "h1" | "h2" | "h3" | "h4" | "h5" | "h6";


// File: /opt/src/epsilon.fm/src/lib/components/ui/menubar/index.ts
import { Menubar as MenubarPrimitive } from "bits-ui";

import Root from "./menubar.svelte";
import CheckboxItem from "./menubar-checkbox-item.svelte";
import Content from "./menubar-content.svelte";
import Item from "./menubar-item.svelte";
import Label from "./menubar-label.svelte";
import RadioItem from "./menubar-radio-item.svelte";
import Separator from "./menubar-separator.svelte";
import Shortcut from "./menubar-shortcut.svelte";
import SubContent from "./menubar-sub-content.svelte";
import SubTrigger from "./menubar-sub-trigger.svelte";
import Trigger from "./menubar-trigger.svelte";

const Menu = MenubarPrimitive.Menu;
const Group = MenubarPrimitive.Group;
const Sub = MenubarPrimitive.Sub;
const RadioGroup = MenubarPrimitive.RadioGroup;

export {
	Root,
	CheckboxItem,
	Content,
	Item,
	Label,
	RadioItem,
	Separator,
	Shortcut,
	SubContent,
	SubTrigger,
	Trigger,
	Menu,
	Group,
	Sub,
	RadioGroup,
	//
	Root as Menubar,
	CheckboxItem as MenubarCheckboxItem,
	Content as MenubarContent,
	Item as MenubarItem,
	Label as MenubarLabel,
	RadioItem as MenubarRadioItem,
	Separator as MenubarSeparator,
	Shortcut as MenubarShortcut,
	SubContent as MenubarSubContent,
	SubTrigger as MenubarSubTrigger,
	Trigger as MenubarTrigger,
	Menu as MenubarMenu,
	Group as MenubarGroup,
	Sub as MenubarSub,
	RadioGroup as MenubarRadioGroup,
};


// File: /opt/src/epsilon.fm/src/lib/components/ui/input/index.ts
import Root from "./input.svelte";

export type FormInputEvent<T extends Event = Event> = T & {
	currentTarget: EventTarget & HTMLInputElement;
};
export type InputEvents = {
	blur: FormInputEvent<FocusEvent>;
	change: FormInputEvent<Event>;
	click: FormInputEvent<MouseEvent>;
	focus: FormInputEvent<FocusEvent>;
	focusin: FormInputEvent<FocusEvent>;
	focusout: FormInputEvent<FocusEvent>;
	keydown: FormInputEvent<KeyboardEvent>;
	keypress: FormInputEvent<KeyboardEvent>;
	keyup: FormInputEvent<KeyboardEvent>;
	mouseover: FormInputEvent<MouseEvent>;
	mouseenter: FormInputEvent<MouseEvent>;
	mouseleave: FormInputEvent<MouseEvent>;
	mousemove: FormInputEvent<MouseEvent>;
	paste: FormInputEvent<ClipboardEvent>;
	input: FormInputEvent<InputEvent>;
	wheel: FormInputEvent<WheelEvent>;
};

export {
	Root,
	//
	Root as Input,
};


// File: /opt/src/epsilon.fm/src/lib/components/ui/accordion/index.ts
import { Accordion as AccordionPrimitive } from "bits-ui";
import Content from "./accordion-content.svelte";
import Item from "./accordion-item.svelte";
import Trigger from "./accordion-trigger.svelte";
const Root = AccordionPrimitive.Root;

export {
	Root,
	Content,
	Item,
	Trigger,
	//
	Root as Accordion,
	Content as AccordionContent,
	Item as AccordionItem,
	Trigger as AccordionTrigger,
};


// File: /opt/src/epsilon.fm/src/lib/components/ui/separator/index.ts
import Root from "./separator.svelte";

export {
	Root,
	//
	Root as Separator,
};


// File: /opt/src/epsilon.fm/src/lib/components/ui/label/index.ts
import Root from "./label.svelte";

export {
	Root,
	//
	Root as Label,
};


// File: /opt/src/epsilon.fm/src/lib/components/ui/dropdown-menu/index.ts
import { DropdownMenu as DropdownMenuPrimitive } from "bits-ui";
import Item from "./dropdown-menu-item.svelte";
import Label from "./dropdown-menu-label.svelte";
import Content from "./dropdown-menu-content.svelte";
import Shortcut from "./dropdown-menu-shortcut.svelte";
import RadioItem from "./dropdown-menu-radio-item.svelte";
import Separator from "./dropdown-menu-separator.svelte";
import RadioGroup from "./dropdown-menu-radio-group.svelte";
import SubContent from "./dropdown-menu-sub-content.svelte";
import SubTrigger from "./dropdown-menu-sub-trigger.svelte";
import CheckboxItem from "./dropdown-menu-checkbox-item.svelte";

const Sub = DropdownMenuPrimitive.Sub;
const Root = DropdownMenuPrimitive.Root;
const Trigger = DropdownMenuPrimitive.Trigger;
const Group = DropdownMenuPrimitive.Group;

export {
	Sub,
	Root,
	Item,
	Label,
	Group,
	Trigger,
	Content,
	Shortcut,
	Separator,
	RadioItem,
	SubContent,
	SubTrigger,
	RadioGroup,
	CheckboxItem,
	//
	Root as DropdownMenu,
	Sub as DropdownMenuSub,
	Item as DropdownMenuItem,
	Label as DropdownMenuLabel,
	Group as DropdownMenuGroup,
	Content as DropdownMenuContent,
	Trigger as DropdownMenuTrigger,
	Shortcut as DropdownMenuShortcut,
	RadioItem as DropdownMenuRadioItem,
	Separator as DropdownMenuSeparator,
	RadioGroup as DropdownMenuRadioGroup,
	SubContent as DropdownMenuSubContent,
	SubTrigger as DropdownMenuSubTrigger,
	CheckboxItem as DropdownMenuCheckboxItem,
};


// File: /opt/src/epsilon.fm/src/lib/components/ui/popover/index.ts
import { Popover as PopoverPrimitive } from "bits-ui";
import Content from "./popover-content.svelte";
const Root = PopoverPrimitive.Root;
const Trigger = PopoverPrimitive.Trigger;
const Close = PopoverPrimitive.Close;

export {
	Root,
	Content,
	Trigger,
	Close,
	//
	Root as Popover,
	Content as PopoverContent,
	Trigger as PopoverTrigger,
	Close as PopoverClose,
};


// File: /opt/src/epsilon.fm/src/lib/components/ui/textarea/index.ts
import Root from "./textarea.svelte";

type FormTextareaEvent<T extends Event = Event> = T & {
	currentTarget: EventTarget & HTMLTextAreaElement;
};

type TextareaEvents = {
	blur: FormTextareaEvent<FocusEvent>;
	change: FormTextareaEvent<Event>;
	click: FormTextareaEvent<MouseEvent>;
	focus: FormTextareaEvent<FocusEvent>;
	keydown: FormTextareaEvent<KeyboardEvent>;
	keypress: FormTextareaEvent<KeyboardEvent>;
	keyup: FormTextareaEvent<KeyboardEvent>;
	mouseover: FormTextareaEvent<MouseEvent>;
	mouseenter: FormTextareaEvent<MouseEvent>;
	mouseleave: FormTextareaEvent<MouseEvent>;
	paste: FormTextareaEvent<ClipboardEvent>;
	input: FormTextareaEvent<InputEvent>;
};

export {
	Root,
	//
	Root as Textarea,
	type TextareaEvents,
	type FormTextareaEvent,
};


// File: /opt/src/epsilon.fm/src/lib/components/ui/button/index.ts
import { type VariantProps, tv } from "tailwind-variants";
import type { Button as ButtonPrimitive } from "bits-ui";
import Root from "./button.svelte";

const buttonVariants = tv({
	base: "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
	variants: {
		variant: {
			default: "bg-primary text-primary-foreground hover:bg-primary/90",
			destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
			outline:
				"border border-input bg-background hover:bg-accent hover:text-accent-foreground",
			secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
			ghost: "hover:bg-accent hover:text-accent-foreground",
			link: "text-primary underline-offset-4 hover:underline",
		},
		size: {
			default: "h-10 px-4 py-2",
			sm: "h-9 rounded-md px-3",
			lg: "h-11 rounded-md px-8",
			icon: "h-10 w-10",
		},
	},
	defaultVariants: {
		variant: "default",
		size: "default",
	},
});

type Variant = VariantProps<typeof buttonVariants>["variant"];
type Size = VariantProps<typeof buttonVariants>["size"];

type Props = ButtonPrimitive.Props & {
	variant?: Variant;
	size?: Size;
};

type Events = ButtonPrimitive.Events;

export {
	Root,
	type Props,
	type Events,
	//
	Root as Button,
	type Props as ButtonProps,
	type Events as ButtonEvents,
	buttonVariants,
};


// File: /opt/src/epsilon.fm/src/lib/components/ui/avatar/index.ts
import Root from "./avatar.svelte";
import Image from "./avatar-image.svelte";
import Fallback from "./avatar-fallback.svelte";

export {
	Root,
	Image,
	Fallback,
	//
	Root as Avatar,
	Image as AvatarImage,
	Fallback as AvatarFallback,
};


// File: /opt/src/epsilon.fm/src/lib/components/ui/badge/index.ts
import { type VariantProps, tv } from "tailwind-variants";
export { default as Badge } from "./badge.svelte";

export const badgeVariants = tv({
	base: "inline-flex select-none items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
	variants: {
		variant: {
			default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
			secondary:
				"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
			destructive:
				"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
			outline: "text-foreground",
		},
	},
	defaultVariants: {
		variant: "default",
	},
});

export type Variant = VariantProps<typeof badgeVariants>["variant"];


// File: /opt/src/epsilon.fm/src/lib/db/schema.ts
import {
	pgTable,
	serial,
	text,
	primaryKey,
	integer,
	varchar,
	date,
	decimal,
	timestamp
} from 'drizzle-orm/pg-core';

export const user = pgTable('user', {
	id: serial('id').primaryKey(),
	authId: varchar('auth_id', { length: 255 }).notNull(),
	birthdate: date('birthdate').notNull(),
	phone: varchar('phone', { length: 15 }),
	address: text('address'),
	referralSource: varchar('referral_source', { length: 255 }), // Better column name for how_did_you_hear_about_us
	anrReferral: varchar('anr_referral', { length: 255 })
});

export const artist = pgTable('artist', {
	id: serial('id').primaryKey(),
	orgId: varchar('org_id', { length: 255 }).unique().notNull(),
	email: varchar('email', { length: 255 }),
	biography: text('biography'),
	spotifyArtistLink: varchar('spotify_artist_link', { length: 255 }),
	youtubeChannelLink: varchar('youtube_channel_link', { length: 255 }),
	instagramProfileLink: varchar('instagram_profile_link', { length: 255 }),
	facebookProfileLink: varchar('facebook_profile_link', { length: 255 }),
	xProfileLink: varchar('x_profile_link', { length: 255 }), // X refers to Twitter
	tiktokProfileLink: varchar('tiktok_profile_link', { length: 255 }),
	soundcloudProfileLink: varchar('soundcloud_profile_link', { length: 255 }),
	songkickProfileLink: varchar('songkick_profile_link', { length: 255 }),
	bandsintownProfileLink: varchar('bandsintown_profile_link', { length: 255 }),
	updatedAt: timestamp('updated_at').defaultNow().notNull()
});

export const genre = pgTable('genre', {
	id: serial('id').primaryKey(),
	name: varchar('name', { length: 50 }).notNull()
});

export const release = pgTable('release', {
	id: serial('id').primaryKey(),
	artistId: integer('artist_id')
		.references(() => artist.id)
		.notNull(),
	title: varchar('title', { length: 100 }).notNull(),
	releaseDate: date('release_date').notNull(),
	description: text('description'),
	spotifyLink: varchar('spotify_link', { length: 255 }),
	youtubeLink: varchar('youtube_link', { length: 255 }),
	soundcloudLink: varchar('soundcloud_link', { length: 255 }),
	appleMusicLink: varchar('apple_music_link', { length: 255 }),
	coverArt: varchar('cover_art', { length: 255 }),
	label: varchar('label', { length: 100 }),
	releaseType: varchar('release_type', { length: 50 }), // Single, Album, EP, etc.
	format: varchar('format', { length: 50 }), // Digital, Vinyl, CD, etc.
	upcCode: varchar('upc_code', { length: 20 }), // Universal Product Code
	updatedAt: timestamp('updated_at').defaultNow().notNull()
});

export const track = pgTable('track', {
	id: serial('id').primaryKey(),
	releaseId: integer('release_id')
		.references(() => release.id)
		.notNull(),
	title: varchar('title', { length: 100 }).notNull(),
	preview: decimal('duration').notNull(), // Start time of the track in seconds
	position: integer('position').notNull(), // Position of the track in the release
	genreId: integer('genre_id')
		.references(() => genre.id)
		.notNull(),
	spotifyLink: varchar('spotify_link', { length: 255 }),
	youtubeLink: varchar('youtube_link', { length: 255 }),
	soundcloudLink: varchar('soundcloud_link', { length: 255 }),
	appleMusicLink: varchar('apple_music_link', { length: 255 }),
	isrcCode: varchar('isrc_code', { length: 20 }), // International Standard Recording Code
	lyrics: text('lyrics'), // Lyrics of the track
	composers: text('composers'), // List of composers
	producers: text('producers'), // List of producers
	engineers: text('engineers'), // List of engineers
	mixingEngineers: text('mixing_engineers'), // List of mixing engineers
	masteringEngineers: text('mastering_engineers'), // List of mastering engineers
	recordingLocation: varchar('recording_location', { length: 255 }), // Studio or location of recording
	credits: text('credits'), // Additional credits
	updatedAt: timestamp('updated_at').defaultNow().notNull()
});

export const trackSubgenre = pgTable(
	'track_subgenre',
	{
		trackId: integer('track_id')
			.references(() => track.id)
			.notNull(),
		subgenreId: integer('subgenre_id')
			.references(() => genre.id)
			.notNull()
	},
	(table) => {
		return {
			pk: primaryKey({ columns: [table.trackId, table.subgenreId] })
		};
	}
);


// File: /opt/src/epsilon.fm/src/lib/db/index.ts
import { sql } from '@vercel/postgres';
import { drizzle } from 'drizzle-orm/vercel-postgres';
import * as schema from './schema';

export const db = drizzle(sql, { schema });


// File: /opt/src/epsilon.fm/src/routes/(website)/a/[slug]/Projects.ts
const projects = [
	{
		title: 'GDLauncher',
		technologies: ['Node', 'React', 'Redux', 'Electron'],
		description:
			'GDLauncher is a simple, yet powerful Minecraft custom launcher with a strong focus on the user experience',
		url: 'https://github.com/gorilla-devs/GDLauncher'
	},
	{
		title: 'WiseMan Discord Bot',
		technologies: ['NodeJs', 'FireBase', 'MongoDb', 'golang'],
		description:
			'The wiseMan bot allows you to level up based on the time you spend in a vocal channel',
		url: 'https://github.com/Ladvace/WiseMan-DiscordBot'
	},
	{
		title: 'Easy-react-carousel',
		technologies: ['React', 'NodeJs'],
		description: 'A simple carousel made in reactjs',
		url: 'https://github.com/Ladvace/easy-react-carousel'
	}
];

export default projects;


// File: /opt/src/epsilon.fm/src/routes/(website)/a/[slug]/+layout.server.ts
import type { LayoutServerLoad } from './$types';
import { clerkClient } from '@clerk/clerk-sdk-node';
import { db } from '$lib/db';
import { artist } from '$lib/db/schema';
import { eq } from 'drizzle-orm';
import { redirect } from '@sveltejs/kit';

export const load = (async ({ params }) => {
	const response = await clerkClient.organizations.getOrganization({
		slug: params.slug
	});
	const data = await db
		.select()
		.from(artist)
		.where(eq(artist.orgId, response.id ?? null));
	if (data.length != 0) {
		return {
			stageName: response.name ?? null,
			imageUrl: response.imageUrl ?? null,
			slug: params.slug,
			email: data[0].email ?? 'hello@epsilonrecords.com',
			biography: data[0].biography ?? null,
			youtubeChannelLink: data[0].youtubeChannelLink ?? null,
			instagramProfileLink: data[0].instagramProfileLink ?? null,
			facebookProfileLink: data[0].facebookProfileLink ?? null,
			tiktokProfileLink: data[0].tiktokProfileLink ?? null,
			soundcloudProfileLink: data[0].soundcloudProfileLink ?? null,
			songkickProfileLink: data[0].songkickProfileLink ?? null,
			bandsintownProfileLink: data[0].bandsintownProfileLink ?? null
		};
	} else {
		redirect(404, '/');
	}
}) satisfies LayoutServerLoad;


// File: /opt/src/epsilon.fm/src/routes/(website)/a/[slug]/Skills.ts
const skills = {
	Genres: ['House', 'Classic House', 'Latin House'],
	Instruments: ['Piano', 'Synthesizer', 'Guitar'],
	Tools: ['Ableton Live'],
	Languages: ['English', 'Spanish'],
	Locations: ['Dallas, TX', 'San Diego, CA']
};

export default skills;


// File: /opt/src/epsilon.fm/src/routes/(website)/a/[slug]/NavRoutes.ts
const routes = [
	{
		href: '/',
		label: 'Home'
	},
	{
		href: '/about',
		label: 'About'
	},
	{
		href: '/music',
		label: 'Music'
	},
	{
		href: '/merch',
		label: 'Merch'
	},
	{
		href: '/contact',
		label: 'Contact'
	}
];

export default routes;


// File: /opt/src/epsilon.fm/src/routes/(website)/a/[slug]/store.ts
import { writable } from 'svelte/store';

export const modalOpened = writable(false);

export const customBackground = writable('#0a0908');


// File: /opt/src/epsilon.fm/src/routes/api/uploadthing/+server.ts
import { UPLOADTHING_SECRET } from '$env/static/private';
import { ourFileRouter } from '$lib/server/uploadthing';

import { createRouteHandler } from 'uploadthing/server';

// The Svelte extension complains if you export the handlers directly
const { GET, POST } = createRouteHandler({
	router: ourFileRouter,
	config: {
		uploadthingSecret: UPLOADTHING_SECRET
	}
});

export { GET, POST };


// File: /opt/src/epsilon.fm/src/routes/(main)/+layout.ts
import { dev } from '$app/environment';
import { inject } from '@vercel/analytics';
import { injectSpeedInsights } from '@vercel/speed-insights/sveltekit';
import posthog from 'posthog-js';
import { browser } from '$app/environment';
import { PUBLIC_POSTHOG_API_KEY } from '$env/static/public';

inject({ mode: dev ? 'development' : 'production' });
injectSpeedInsights();

/** @type {import('./$types').PageLoad} */
export const load = async () => {
	if (browser) {
		posthog.init(PUBLIC_POSTHOG_API_KEY, {
			api_host: 'https://eu.i.posthog.com',
			person_profiles: 'identified_only' // or 'always' to create profiles for anonymous users as well
		});
	}
	return;
};


// File: /opt/src/epsilon.fm/src/routes/(main)/+page.server.ts
import type { PageServerLoad } from './$types.js';
import { clerkClient } from '@clerk/clerk-sdk-node';

export const load: PageServerLoad = async ({ locals }) => {
	let slug = '';
	console.log(locals);

	// Use type assertion to access 'session'
	const session = (locals as { session?: { claims?: { org_id?: string } } }).session;

	if (session && session.claims && session.claims.org_id) {
		const organizationId = session.claims.org_id;
		const response = await clerkClient.organizations.getOrganization({ organizationId });
		slug = response.slug ?? '';
	}

	return {
		slug: slug
	};
};


// File: /opt/src/epsilon.fm/src/routes/(main)/+layout.server.ts
import type { LayoutServerLoad } from './$types';
import { NODE_ENV, VERCEL_GIT_COMMIT_SHA } from '$env/static/private';

export const load: LayoutServerLoad = async () => {
	return {
		nodeEnv: NODE_ENV,
		gitCommitSha: VERCEL_GIT_COMMIT_SHA
	};
};


// File: /opt/src/epsilon.fm/src/routes/(main)/profile/schema.ts
import { z } from 'zod';

const artistSchema = z.object({
	id: z.number().optional(),
	orgId: z.string().max(255),
	slug: z.string().max(255),
	stageName: z.string().max(50),
	email: z.string().max(255),
	biography: z.string().max(1000),
	spotifyArtistLink: z.string().max(255).optional(),
	youtubeChannelLink: z.string().max(255).optional(),
	instagramProfileLink: z.string().max(255).optional(),
	facebookProfileLink: z.string().max(255).optional(),
	xProfileLink: z.string().max(255).optional(), // X refers to Twitter
	tiktokProfileLink: z.string().max(255).optional(),
	soundcloudProfileLink: z.string().max(255).optional(),
	songkickProfileLink: z.string().max(255).optional(),
	bandsintownProfileLink: z.string().max(255).optional()
});

const genreSchema = z.object({
	id: z.number().optional(),
	name: z.string().max(50)
});

const releaseSchema = z.object({
	id: z.number().optional(),
	artistId: z.number(),
	title: z.string().max(100),
	releaseDate: z.string(), // Using string to represent date
	description: z.string().optional(),
	spotifyLink: z.string().max(255).optional(),
	youtubeLink: z.string().max(255).optional(),
	soundcloudLink: z.string().max(255).optional(),
	appleMusicLink: z.string().max(255).optional(),
	coverArt: z.string().max(255).optional(),
	label: z.string().max(100).optional(),
	releaseType: z.string().max(50).optional(), // Single, Album, EP, etc.
	format: z.string().max(50).optional(), // Digital, Vinyl, CD, etc.
	upcCode: z.string().max(20).optional() // Universal Product Code
});

const trackSchema = z.object({
	id: z.number().optional(),
	releaseId: z.number(),
	title: z.string().max(100),
	preview: z.number(),
	position: z.number(),
	genreId: z.number(),
	spotifyLink: z.string().max(255).optional(),
	youtubeLink: z.string().max(255).optional(),
	soundcloudLink: z.string().max(255).optional(),
	appleMusicLink: z.string().max(255).optional(),
	isrcCode: z.string().max(20).optional(), // International Standard Recording Code
	lyrics: z.string().optional(), // Lyrics of the track
	composers: z.string().optional(), // List of composers
	producers: z.string().optional(), // List of producers
	engineers: z.string().optional(), // List of engineers
	mixingEngineers: z.string().optional(), // List of mixing engineers
	masteringEngineers: z.string().optional(), // List of mastering engineers
	recordingLocation: z.string().max(255).optional(), // Studio or location of recording
	credits: z.string().optional() // Additional credits
});

const trackSubgenreSchema = z.object({
	trackId: z.number(),
	subgenreId: z.number()
});

export type ArtistSchema = typeof artistSchema;

export { artistSchema, genreSchema, releaseSchema, trackSchema, trackSubgenreSchema };


// File: /opt/src/epsilon.fm/src/routes/(main)/profile/+page.server.ts
import type { PageServerLoad, Actions } from './$types.js';
import { message, superValidate } from 'sveltekit-superforms';
import { zod } from 'sveltekit-superforms/adapters';
import { artistSchema } from './schema';
import { db } from '$lib/db';
import { artist } from '$lib/db/schema';
import { eq } from 'drizzle-orm';
import { clerkClient } from '@clerk/clerk-sdk-node';
import { redirect, fail } from '@sveltejs/kit';

export const load: PageServerLoad = async ({ locals }) => {
	// Use type assertion to access 'session'
	const session = (locals as { session?: { claims?: { org_id?: string } } }).session;
	let form = await superValidate(zod(artistSchema));
	if (session && session.claims && session.claims.org_id) {
		const organizationId = session.claims.org_id ?? null;
		const response = await clerkClient.organizations.getOrganization({ organizationId });
		const stageName = response.name ?? null;
		const slug = response.slug ?? null;
		if (!organizationId || !stageName || !slug) {
			throw redirect(500, '/');
		}
		const data = await db.select().from(artist).where(eq(artist.orgId, organizationId));
		if (data.length != 0) {
			// Convert null values to undefined
			const formattedData = Object.fromEntries(
				Object.entries(data[0]).map(([key, value]) => [key, value === null ? undefined : value])
			);
			form = await superValidate(formattedData, zod(artistSchema), { strict: true });
		}
		form.data.orgId = organizationId;
		form.data.stageName = stageName;
		form.data.slug = slug;
	}
	return {
		form: form
	};
};

export const actions: Actions = {
	default: async (request) => {
		const form = await superValidate(request, zod(artistSchema), { strict: true });
		if (!form.valid) {
			return fail(400, {
				form
			});
		}
		try {
			await db.insert(artist).values(form.data).onConflictDoUpdate({
				target: artist.orgId,
				set: form.data
			});
		} catch {
			return fail(500, {
				form
			});
		}
		return message(form, 'success');
	}
};


// File: /opt/src/epsilon.fm/src/routes/(main)/artists/+page.server.ts
import type { PageServerLoad } from './$types.js';
import { clerkClient } from '@clerk/clerk-sdk-node';

export const load: PageServerLoad = async () => {
	const response = await clerkClient.organizations.getOrganizationList({
		limit: 10,
		offset: 0,
		includeMembersCount: true
	});
	console.log(response);
	return {
		artists: JSON.parse(JSON.stringify(response.data))
	};
};

